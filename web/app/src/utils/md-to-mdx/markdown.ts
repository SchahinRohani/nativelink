import type { Root, RootContent } from "mdast";
import { remark } from "remark";
import remarkMdx from "remark-mdx";
import remarkParse from "remark-parse";
import remarkStringify from "remark-stringify";

import {
  extractAndReplaceAlignAndParagraph,
  extractTitle,
  generateAssetImports,
  preserveInlineCode,
  transformGitHubMarkdown,
} from "./ast/transform";

import { findNodesById, logFirstNNodes } from "./ast/debug";

export type convertFile = {
  input: string;
  output: string;
  title: string;
  pagefind?: boolean;
};

export function parseMarkdown(markdown: string): Root {
  return remark().use(remarkParse).parse(markdown) as Root;
}

export function preProcessMarkdown(markdown: string): string {
  const processed = markdown
    .replace(/<!--\s*vale\s+(on|off)\s*-->/g, "")
    .replace(/<!--\s*generated by git-cliff\s*-->/g, "");

  const lines = processed.split("\n");
  const processedLines = [];
  let inMermaidBlock = false;
  let inCodeBlock = false;

  for (const line of lines) {
    if (line.trim().startsWith("```mermaid")) {
      inMermaidBlock = true;
      processedLines.push(line);
      continue;
    }
    if (inMermaidBlock && line.trim() === "```") {
      inMermaidBlock = false;
      processedLines.push(line);
      continue;
    }

    if (line.trim().startsWith("```") && !inMermaidBlock) {
      inCodeBlock = !inCodeBlock;
      processedLines.push(line);
      continue;
    }

    if (inMermaidBlock || inCodeBlock) {
      processedLines.push(line);
      continue;
    }

    if (
      line.trim().startsWith(">") ||
      /^\[!(TIP|NOTE|WARNING|IMPORTANT|CAUTION)\]/.test(line)
    ) {
      processedLines.push(line);
      continue;
    }

    const htmlTagPattern = /^[<\s][^>]*>/g;
    if (htmlTagPattern.test(line)) {
      processedLines.push(line);
    } else {
      processedLines.push(line.replace(/</g, "&lt;").replace(/>/g, "&gt;"));
    }
  }

  return processedLines.join("\n");
}

export function generateFrontMatter(
  title: string,
  description: string,
  pagefind = true,
): string {
  return `---
title: "${title}"
description: "${description}"
pagefind: ${pagefind ? "true" : "false"}
---
`;
}

type markdownProps = {
  title: string;
  description: string;
  pagefind?: boolean;
  assets?: string[];
};

export async function transformMarkdownToMdx(
  input: string,
  docs: markdownProps,
): Promise<string> {
  const preprocessedMarkdown = preProcessMarkdown(input);
  const tree = parseMarkdown(preprocessedMarkdown);

  // Extract title and content
  const { title, content } = extractTitle(tree);

  // Apply transformations in sequence

  // Prepend the import statements to the content
  let transformedContent = [...content];

  if (docs.assets) {
    transformedContent = [...generateAssetImports(docs.assets), ...content];
  }

  // Array of target IDs to iterate over
  const targetIds = ["logo", "description", "badges"];

  // Iterate over the target IDs and apply the transformation
  for (const targetId of targetIds) {
    transformedContent = extractAndReplaceAlignAndParagraph(
      transformedContent,
      targetId,
    ).content;
  }

  // GitHub Markdown specific transformations
  transformedContent = transformGitHubMarkdown(transformedContent);

  // Preserve inline code
  transformedContent = preserveInlineCode(transformedContent);

  // Reassemble the tree with the transformed content
  tree.children = transformedContent;

  // console.log(tree)

  // Convert the transformed tree back to Markdown
  const modifiedMarkdown = remark().use(remarkStringify).stringify(tree);

  // Convert Markdown to MDX
  const processedMdx = await remark()
    .use(remarkParse)
    .use(remarkMdx)
    .use(remarkStringify)
    .process(modifiedMarkdown);

  // Generate front matter
  const frontMatter = generateFrontMatter(
    docs.title,
    docs.description,
    docs.pagefind,
  );

  // Return the final MDX content
  return frontMatter + String(processedMdx);
}
